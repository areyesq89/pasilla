%\VignetteIndexEntry{RNA-seq analysis with DESeq, differential expression, and DEXSeq, differential exon usage}
%\VignetteDepends{DESeq, edgeR, locfit}
%\VignetteKeywords{Expression Analysis}
%\VignettePackage{}

\documentclass{article}

\usepackage{Sweave}
\usepackage[a4paper]{geometry}
\usepackage{hyperref,graphicx}
\usepackage{cite}
\usepackage{color}

\SweaveOpts{keep.source=TRUE,eps=FALSE,include=FALSE,height=4.5,width=4} 
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}
\newcommand{\fixme}[1]{{\par Fixme: \textit{\textcolor{blue}{#1}}}}

\title{\textsf{\textbf{RNA-seq practical lab CSAMA 2011 \\ Bressanone-Brixen, Italy}}}
\author{Wolfgang Huber, Alejandro Reyes}

\begin{document}
\maketitle
\begin{abstract}
To be written
\end{abstract}

% %%%%% Data description can be find in the vignette that creates the exons. GC content bias might not be very relevant for this analysis.

%\section{Data description of the data}
%The data set was aligned using tophat which allows to map spliced reads.  The data consists in 4 biological replicates (2 paired-end and 2 single-read) of an untreated S2-DRSC fly cell line and 3 biological replicates of the same cell line treated with a double stranded iRNA against the gene GS8144 which is supposed to be involved in mRNA binding in the spliceosome. It has been previously described by RT-PCR experiments that a knockdown of this protein affects the splicing of Dscam and para genes(Park et al, 2004). This is a summary each of the biological replicates. The reads were aligned with tophat version 12.0 and assigned to counts features using in-house python scripts. The gtf annotation file used is available in the supplementary material of the article.
%\\
%\begin{centering}
%\begin{tabular}{| c | c | p{1 cm} | c | c | c |}
%  \hline
%  lane & type & lanes & number of reads & counts \\
%  \hline
%  treated1gr & single-read & 5 & 35158667 & 8253967\\
%  treated2gr & paired-end & 2 & 12242535 & 7905183 \\
%  treated3gr & paired-end & 2 & 12443664 & 9748861 \\
%  untreated1gr & single-read & 2 & 17812866 & 7904717 \\
%  untreated2gr & single-read & 6 & 34284521 & 11123025 \\
%  untreated3gr & paired-end & 2 & 10542625 & 8018900 \\
%  untreated4gr & paired-end & 2 & 12214974 & 8489993 \\
%  \hline  
%\end{tabular}
%\end{centering}
%\\
%\\
%The reads taken into account for the analysis are the uniquely mapped reads that fall into coding regions.  The count table for the genes is already available as a data frame in a test file file.
%\section{Sample checking}
%Several papers have described distinct sequencing biases that may alter the subsequent downstream analysis (e.g. PCR bias \cite{Aird2011}).  One very common sequencing bias that can be evaluated at this stage of the analysis is GC content biases, meaning that the counts might be enriched or diminished towards high or low GC content regions \cite{Pickrell2010}.  If these biases are different between samples, this might cause an undesired effect further in the analysis.  We will start checking our data for GC content biases difference between our samples.  An RData object containing a vector of G C content per gene has been created for this purpose with inhouse perl scripts.  We can first filter those genes for which we do not have expression data which have no sense to test for differential expression.

%<<load, echo=TRUE, eval=TRUE, fig=FALSE>>=
%library("pasilla")

%data("gene_counts", package="pasilla")
%data("gcpergene") 

%head(gene_counts)
%head(gcpergene)
%@ 
%First, we eliminate those table rows in which all counts are 0, and subset \Robject{gcpergene} such that its elements and their order align with the rows of \Robject{gene\_counts}.
%<<reorder, echo=TRUE, eval=TRUE, fig=FALSE>>=
%nonZero = (rowSums(gene_counts) > 0)
%gene_counts = gene_counts[nonZero, ]

%stopifnot(all(rownames(gene_counts) %in% names(gcpergene)))
%gcpergene = gcpergene[rownames(gene_counts)]
%@

%To see if we have a bias towards GC content, we check the relative enrichment of each gene of each sample compared to the other samples with the formula \\ \\
%$  f_{lj} = log(\frac{s_{lj} / \sum_{j} {s_{lj}} } 
%		{ \sum_{l} {s_{lj}} / \sum_{l} {\sum_{j} {s_{lj}} } } )  $
%\\ \\
%where j is a gene count from the lane j.  If there were a GC enrichment towards one of the samples they should be clear when plotting $f_{lj}$ against GC content. We then fit a \Rfunction{locfit}, we would expect a horizontal line on $f_{lj} = 0 $ if there is no enrichment. When taking into account all the samples, we could say that there seems to be a GC content bias towards some of the samples. \\
%<<gcbias, echo=TRUE, fig=TRUE, height=10, width=12>>=
%flj <- log2((gene_counts/rowSums(gene_counts))/(colSums(gene_counts)/sum(gene_counts)))
%par(mfrow=c(2, 4))
%library(locfit)
%for(i in 1:ncol(flj)){
%	smoothScatter(gcpergene, flj[,i], ylim=c(-3,2), main=paste("gccontent vs flj", colnames(flj)[i]))
%	lines(locfit(flj[,i][!is.infinite(flj[,i])]~gcpergene[!is.infinite(flj[,i])]))
%}
%@
%\begin{figure}
%\centering
%\includegraphics[width=\textwidth]{RNAseq_lab-gcbias}
%\caption{$f_{lj}$ vs GC content. We would not expect any enrichment dependent on GC content, but we can see that indeed there is some.}
%\end{figure}
%Doing exactly the same procedure separating the samples depending of the type of library we see that the effect clearly diminishes. (Repeat the figures 2 and 3) This kind of effects are not easy to explain or to trace their origin, but they should be consider into account for the downstream analysis.  Marioni et al \cite{Pickrell2010} propose a methods to correct for this directly in the count data by scaling by a factor obtained from the linear regression.  In this case we will take care of it by consider the type of library as a factor when doing the tests (see section Multiple Factor experiments).
%<<pairedgc, echo=FALSE, fig=TRUE, height=10, width=12>>=
%paired <- gene_counts[,c(2,3,6,7)]
%par(mfrow=c(2, 2))
%flj <- log2((paired/rowSums(paired))/(colSums(paired)/sum(paired)))
%for(i in 1:ncol(flj)){
%	smoothScatter(gcpergene, flj[,i], ylim=c(-3,2), main=paste("gccontent vs flj", colnames(flj)[i]))
%	lines(locfit(flj[,i][!is.infinite(flj[,i])]~gcpergene[!is.infinite(flj[,i])]))
%}
%@
%\begin{figure}
%\centering
%\includegraphics[width=\textwidth]{RNAseq_lab-pairedgc}
%\caption{$f_{lj}$ vs GC content using only the paired-end libraries samples to calculate $f_{lj}$.}
%\end{figure}
%<<singlegc, echo=FALSE, fig=TRUE, height=5, width=12>>=
%single <- gene_counts[,c(1,4,5)]
%par(mfrow=c(1, 3))
%flj <- log2((single/rowSums(single))/(colSums(single)/sum(single)))
%for(i in 1:ncol(flj)){
%	smoothScatter(gcpergene, flj[,i], ylim=c(-3,2), main=paste("gccontent vs flj", colnames(flj)[i]))
%	lines(locfit(flj[,i][!is.infinite(flj[,i])]~gcpergene[!is.infinite(flj[,i])]))
%}
%@
%\begin{figure}
%\centering
%\includegraphics[width=\textwidth]{RNAseq_lab-singlegc}
%\caption{$f_{lj}$ vs GC content using only the single-read libraries samples to calculate $f_{lj}$.}
%\end{figure}
%\\
\section{Variance estimation.}
When testing for differential expression in RNA-seq samples, it is important to distinguish between the changes in the counts that can be attributed to biological noise from real changes in expression.  In order to have an estimate of this variance between samples of the same condition, the use of biological replicates is fundamental. Normally, the  process of counting reads that fall into a genomic feature can be approximated with a Poisson distribution, where the mean is equal to the variance, but it has been shown that this assumption is to tight and predicts variations smaller than those observed in the data.  This normally tends to give a large number of false positives genes, therefore the proper estimation of the dispersion between samples is essential to properly call for differential expression. 

The BioC packages \Rpackage{DESeq} \cite{Anders2010} and \Rpackage{edgeR} \cite{Robinson2010} use a negative binomial distribution instead of a Poisson, that allows more flexible estimations of the variance between the samples, nevertheless the estimation of this variances is not easy when the number of biological replicates is small, e.g. most hight-throughput sequencing experiments.  The main difference between the packages rely in the way this dispersion estimation is done.  (If you want to give a rough look into the variance between samples, try plotting the log counts of a sample vs another one of the same condition).  In the next two subsections, we will follow a DESeq and edgeR pipeline to get the variance estimates and to test for differential expression.
\\ 
\fixme{AR: Should I get into the details of the estimations of the dispersion?}
\subsection{DESeq Analysis}
The package \Rpackage{DESeq} uses a \Rclass{CountDataSet} object. It is based on the \Rclass{eSet}, so it shares all features for this class in addition to accessors for the data slots and functions for variance diagnostics, variance estimation and testing for differential expression. The first steps to start an analysis with DESeq is to make an \Rclass{CountDataSet} object using our count table.  In the \Rpackage{pasilla} package you will find the object \Robject{pasillaGenes}, which contains an CountDataSeq object.  If you prefer to create your own object with your own data, you will find a vignette in the pasilla package with information of how the object was created. \\ \\
The sequencing depth between two identical samples can vary causing the count values to be different between each other and might confuse our analysis for differential expression, DESeq estimates size factors to take this into account using the function \Rfunction{estimateSizeFactors}.
<<ecs,echo=TRUE, eval=TRUE, fig=FALSE>>=
library("DESeq")
data("pasillaGenes", package="pasilla")
pasillaGenes
pData(pasillaGenes)
pasillaGenes <- pasillaGenes[-which( rowSums(counts(pasillaGenes)) == 0 ),]
pasillaGenes <- DESeq::estimateSizeFactors(pasillaGenes)
@
As we can see in the phenoData of the CountDataSet object, there are differences the library preparation, some of the replicates are single read libraries while others are paired-end libraries.  For the moment we will take off the library type from the phenoData, assuming that the library preparation does not have an effect in our samples. 
\fixme{ some of the DESeq functions do not work when the phenoData has more than the condition and size factor columns }
<<ecs,echo=TRUE, eval=TRUE, fig=FALSE>>=
pData(pasillaGenes) <- pData(pasillaGenes)[,c(1,2)]
pasillaGenes@multivariateConditions <- FALSE
@
\Rpackage{DESeq} assumes that similar expressions of genes have also similar variances. For each condition it creates a function trying to predict the variance from the mean, this is done by calculating the mean and variance of the data and fitting a curve on it.  This is of course already implemented in the function \Rfunction{estimateVarianceFunctions}.  The package also provides functions to visualize and evaluate the determined variance functions.
<<echo=TRUE, eval=TRUE, fig=FALSE>>=
pasillaGenes <- estimateVarianceFunctions(pasillaGenes)
@
To make a quick check of all the functions in a plot, the function \Rfunction{svcPlot} plots the square coefficients of variation for each of the conditions.  The solid colored lines represent the noise related to biological replication.  In addition to this, each of the dashed colored lines (one per sample) represent the full variance scaled with the size factors.  The difference between the dashed line and the solid line of the same color would be the shot noise, which we have even if we sequence the same RNA sample in different lanes. Note that as the base mean decreases, the shot noise increases: this is totally expected under the Poisson process of counting RNA-seq reads in genomic features.
<<scv, echo=TRUE, fig=TRUE>>=
scvPlot(pasillaGenes)
@
\begin{figure}
\centering
\includegraphics[width=4in, height=5in]{RNAseq_lab-scv}
\caption{svcPlot}
\end{figure}
\subsubsection{Clustering}
DESeq paper also talks about the application of variance stabilizing transformation for the visualization of the data.  The reason of this is that if we want to make come kind of exploration of our samples (e.g. clustering), the fact that the low counts increases the variance can cause that our analysis not to be appropriate, not having much sense.  DESeq provides the function \Rfunction{getVarianceStabilizedData}, the result is a pseudocount table where the variance is not dependent anymore on the mean. In this section we use this function to get out pseudocounts and make a heatmap of our samples. Can you see specific clusters? (Figure 5)
<<cluster, echo=TRUE, fig=TRUE>>=
pcounts <- getVarianceStabilizedData(pasillaGenes)
heatmap(as.matrix(dist(t(pcounts))), cexRow=0.9, cexCol=0.9, symm=TRUE)
@
\begin{figure}
\centering
\includegraphics[width=5in, height=5in]{RNAseq_lab-cluster}
\caption{Clustering of the samples applying the variance stabilizing function.}
\end{figure}
\subsubsection{Variance diagnostics}
Both our initial GC content analysis and our clustering approach with our variance stabilized data indicates that there are clear differences between the samples that depend in the type of library used.  To see the effect on the library type in the variance estimation, we can use the function \Rfunction{residualsEcdsPlot}. The idea behind this plot is that usually we have very few replicates, so some of the actual gene empirical variances might deviate a lot from the variance function estimation, the function \Rfunction{varianceFitDiagnostics} calculates the cumulative probability of the ratio of single-gene estimates over the fitted value from the estimated function using a $ \chi^2 $ distribution. The \Rfunction{residualsEcdsPlot} function allow us to see how good our function is fitting to the data plotting the empirical cumulative density vs its $ \chi^2 $ values.  One would expect the $\chi^2$ values to be uniformly distributed, meaning on the diagonal of the plot.
<<ecdf, echo=TRUE, fig=TRUE, height=5, width=12>>=
pairedpasillaGenes <- pasillaGenes[,c(2, 3, 6, 7)]
pairedpasillaGenes <- estimateVarianceFunctions(pairedpasillaGenes)
singlepasillaGenes <- pasillaGenes[,c(1, 4, 5)]
singlepasillaGenes <- estimateVarianceFunctions(singlepasillaGenes)
par(mfrow=c(1,3))
residualsEcdfPlot(pasillaGenes, "untreated")
residualsEcdfPlot(singlepasillaGenes, "untreated")
residualsEcdfPlot(pairedpasillaGenes, "untreated")
@
\begin{figure}
\centering
\includegraphics{RNAseq_lab-ecdf}
\caption{residualsEcdf plots for (1) all libraries, (2) just single-read libraries and (3) just paired-end libraries. (left to right)}
\end{figure}
What this kind of plot indicates us is how good is the fit to the data.  If our lines are above the expected line (diagonal), this means that we are overestimating the variance and we are going to loose power at the time of testing, if it is below the line means that we are underestimating the variance and this could be dangerous because we would loose control of false positives.  In our plots we can see that when we mix the single-read and paired-end samples, we have a overestimation of our variance estimates and therefore we would loose some power at the time of testing.  In the next two subsections, we will do the actual testing for differential expression, first we will use a single factor analysis using just the paired-end libraries and then we will take advantage of the GLMs multiple factor analysis to mix the single-read and paired-end data adding the library type as part of the experimental design.
\section{Testing for differential expression}
\subsubsection{Single factor analysis}
In order to show how would be the analysis of a single factor experiment, we will only take the paired end samples. DESeq allows to do simple pairwise comparisons for this cases with the function \Rfunction{nbinomTest}.
<<echo=TRUE, eval=TRUE, fig=FALSE>>=
res <- nbinomTest(pasillaGenes, "treated", "untreated")
table(res$padj < 0.1)
@
A classical way to visualize the results of the test is plotting the log2 fold change and mean.  The so called M vs A plots. (Figure 7) What can you conclude from this plot based on what we have say about the variance estimations?
<<mvsa, echo=TRUE, fig=TRUE, height=5, width=5>>=
plot(res$baseMean, res$log2FoldChange, log='x', col=ifelse(res$padj < 0.1, "red", "black"), pch=".")
abline(h=0, col="blue")
@
\begin{figure}
\centering
\includegraphics{RNAseq_lab-mvsa}
\caption{residualsEcdf plots for (1) all libraries, (2) just single-read libraries and (3) just paired-end libraries. (left to right)}
\end{figure}
\subsubsection{Multiple factor analysis}
Now lets imagine that we have more than one condition per sample, a simple pairwise \Rfunction{nbinomTest} would not be enough to take into account all the factors.  Here is where we come to the application of generalized linear models (GLM) for the analysis of multivariate data. For example, in this case we have libraries that are treated with the siRNA and untreated, but we also have two type of library preparations, single-read and paired-end.  We saw before that we have an extra source of variance in this, by applying a GLM we are able to distinguish the real signal from the extra noise introduced by the type of library preparation.
<<echo=TRUE, eval=TRUE, fig=FALSE>>=
data("pasillaGenes", package="pasilla")
pasillaGenes <- estimateSizeFactors(pasillaGenes)
pData(pasillaGenes)
@
In the simple factor design, the calculation of the variance was straightforward, one function describing the variance of each of the conditions.  In this case it is not that simple because of the complexity of our factors.  In this case \Rpackage{DESeq} uses a different approach to calculate the dispersion, it calculates a pool variance function of all the samples. 
<<echo=TRUE, eval=TRUE, fig=FALSE>>=
pasillaGenes <- estimateVarianceFunctions(pasillaGenes, method="pooled")
@
To make the GLM, we have to make a FULL model and a reduced model. We can fit both using the function \Rfunction{nbinomFitGLM}, in this case our reduce model will contain the library type preparation while our full model will contain both the library type preparation and the condition we are testing for.  With this we make sure that the changes in the expression are real changes in expression and not noise introduced by mixing the libraries. We finally use \Rfunction{nbinomTest} to compare the fits on the data.
<<echo=TRUE, eval=TRUE, fig=FALSE>>=
fit1 <- nbinomFitGLM( pasillaGenes, count ~ libType + condition )
fit0 <- nbinomFitGLM( pasillaGenes, count ~ libType )
pvals <- nbinomGLMTest( fit1, fit0 )
table(p.adjust(pvals, method="BH") < 0.1)
@
\subsection{edgeR analysis}
\bibliography{library}
\bibliographystyle{plain}
\end{document}
